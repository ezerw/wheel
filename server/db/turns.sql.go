// Code generated by sqlc. DO NOT EDIT.
// source: turns.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTurn = `-- name: CreateTurn :execresult
INSERT INTO turns (person_id, team_id, date)
VALUES ( ?, ?, ? )
`

type CreateTurnParams struct {
	PersonID int64     `json:"person_id"`
	TeamID   int64     `json:"team_id"`
	Date     time.Time `json:"date"`
}

func (q *Queries) CreateTurn(ctx context.Context, arg CreateTurnParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTurn, arg.PersonID, arg.TeamID, arg.Date)
}

const deleteTurn = `-- name: DeleteTurn :exec
DELETE FROM turns
WHERE id = ?
AND team_id = ?
`

type DeleteTurnParams struct {
	ID     int64 `json:"id"`
	TeamID int64 `json:"team_id"`
}

func (q *Queries) DeleteTurn(ctx context.Context, arg DeleteTurnParams) error {
	_, err := q.db.ExecContext(ctx, deleteTurn, arg.ID, arg.TeamID)
	return err
}

const getTurn = `-- name: GetTurn :one
SELECT id, person_id, team_id, date, created_at
FROM turns
WHERE id = ?
AND team_id = ?
LIMIT 1
`

type GetTurnParams struct {
	ID     int64 `json:"id"`
	TeamID int64 `json:"team_id"`
}

func (q *Queries) GetTurn(ctx context.Context, arg GetTurnParams) (Turn, error) {
	row := q.db.QueryRowContext(ctx, getTurn, arg.ID, arg.TeamID)
	var i Turn
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.TeamID,
		&i.Date,
		&i.CreatedAt,
	)
	return i, err
}

const getTurnByDate = `-- name: GetTurnByDate :one
SELECT id, person_id, team_id, date, created_at
FROM turns
WHERE date = ?
AND team_id = ?
LIMIT 1
`

type GetTurnByDateParams struct {
	Date   time.Time `json:"date"`
	TeamID int64     `json:"team_id"`
}

func (q *Queries) GetTurnByDate(ctx context.Context, arg GetTurnByDateParams) (Turn, error) {
	row := q.db.QueryRowContext(ctx, getTurnByDate, arg.Date, arg.TeamID)
	var i Turn
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.TeamID,
		&i.Date,
		&i.CreatedAt,
	)
	return i, err
}

const listTurns = `-- name: ListTurns :many
SELECT id, person_id, team_id, date, created_at
FROM turns
WHERE team_id = ?
ORDER BY date DESC
LIMIT ?
OFFSET ?
`

type ListTurnsParams struct {
	TeamID int64 `json:"team_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTurns(ctx context.Context, arg ListTurnsParams) ([]Turn, error) {
	rows, err := q.db.QueryContext(ctx, listTurns, arg.TeamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Turn{}
	for rows.Next() {
		var i Turn
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.TeamID,
			&i.Date,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTurnsWithBothDates = `-- name: ListTurnsWithBothDates :many
SELECT id, person_id, team_id, date, created_at
FROM turns
WHERE team_id = ?
AND date >= ?
AND date <= ?
ORDER BY date DESC
LIMIT ?
OFFSET ?
`

type ListTurnsWithBothDatesParams struct {
	TeamID int64     `json:"team_id"`
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListTurnsWithBothDates(ctx context.Context, arg ListTurnsWithBothDatesParams) ([]Turn, error) {
	rows, err := q.db.QueryContext(ctx, listTurnsWithBothDates,
		arg.TeamID,
		arg.Date,
		arg.Date_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Turn{}
	for rows.Next() {
		var i Turn
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.TeamID,
			&i.Date,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTurnsWithDateFrom = `-- name: ListTurnsWithDateFrom :many
SELECT id, person_id, team_id, date, created_at
FROM turns
WHERE team_id = ?
AND date >= ?
ORDER BY date DESC
LIMIT ?
OFFSET ?
`

type ListTurnsWithDateFromParams struct {
	TeamID int64     `json:"team_id"`
	Date   time.Time `json:"date"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListTurnsWithDateFrom(ctx context.Context, arg ListTurnsWithDateFromParams) ([]Turn, error) {
	rows, err := q.db.QueryContext(ctx, listTurnsWithDateFrom,
		arg.TeamID,
		arg.Date,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Turn{}
	for rows.Next() {
		var i Turn
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.TeamID,
			&i.Date,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTurnsWithDateTo = `-- name: ListTurnsWithDateTo :many
SELECT id, person_id, team_id, date, created_at
FROM turns
WHERE team_id = ?
AND date <= ?
ORDER BY date DESC
LIMIT ?
OFFSET ?
`

type ListTurnsWithDateToParams struct {
	TeamID int64     `json:"team_id"`
	Date   time.Time `json:"date"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListTurnsWithDateTo(ctx context.Context, arg ListTurnsWithDateToParams) ([]Turn, error) {
	rows, err := q.db.QueryContext(ctx, listTurnsWithDateTo,
		arg.TeamID,
		arg.Date,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Turn{}
	for rows.Next() {
		var i Turn
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.TeamID,
			&i.Date,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTurn = `-- name: UpdateTurn :execresult
UPDATE turns
SET person_id = ?, team_id = ?, date = ?
WHERE id = ?
`

type UpdateTurnParams struct {
	PersonID int64     `json:"person_id"`
	TeamID   int64     `json:"team_id"`
	Date     time.Time `json:"date"`
	ID       int64     `json:"id"`
}

func (q *Queries) UpdateTurn(ctx context.Context, arg UpdateTurnParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTurn,
		arg.PersonID,
		arg.TeamID,
		arg.Date,
		arg.ID,
	)
}
